import "../node_modules/paper/dist/paper-core.js"; paper.install(window); class DrawFigures { constructor() { this.points = [], this.it = 0, this.x0 = null, this.y0 = null, this.point1 = null, this.point2 = null, this.point3 = null, this.prlg = null, this.circle = null, this.centerPoint = null, this.canvas = document.querySelector("canvas"), this.btn = document.querySelector(".reset"), this.info = document.querySelector(".info"), this.ctx = this.canvas.getContext("2d"), this.disclaimer = document.querySelector(".disclaimer"), this.title = document.querySelector(".title"), this.description = document.querySelector(".description"), this.help = document.querySelector(".help"), this.close = document.querySelector(".close"), this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight, this.title.addEventListener("mousedown", t => this.initDrawing(t)), this.canvas.addEventListener("mousedown", t => this.initDrawing(t)), this.btn.addEventListener("mousedown", () => this.resetCanvas()), this.help.addEventListener("mousedown", () => this.showDescription()), this.close.addEventListener("mousedown", () => this.closeDescription()), this.setupPaper() } setupPaper() { paper.setup("canvas") } showDescription() { this.disclaimer.classList.add("isHidden"), this.description.classList.remove("isHidden") } closeDescription() { this.disclaimer.classList.remove("isHidden"), this.description.classList.add("isHidden") } initDrawing(t) { this.disclaimer.remove(), this.description.remove(), this.btn.classList.remove("isHidden"), this.generatePoints(t.clientX, t.clientY) } generatePoints(t, i) { this.it < 3 && (this.points.push({ x: t, y: i }), this.drawPoint(t, i), this.info.innerHTML += `\n        <p class="point${this.it + 1}">\n          point${this.it + 1}: x: ${t}; y: ${i}\n        </p>\n      `, 2 === this.it && (this.drawCircle(this.drawParallelogram()), this.drawCenterPoint(this.x0, this.y0)), this.it++) } drawPoint(t, i) { const e = `point${this.it + 1}`; this[e] = new Path.Circle(new Point(t, i), 11), this[e].fillColor = "red", this[e].on("mousedrag", t => { this.prlg && (this.redrawParallelogram(e, t), this.redrawCircle(), this.redrawCenterPoint(), this.updatePointInfo(e, t), this.updateAreaInfo()) }) } updatePointInfo(t, i) { document.querySelector(`.${t}`).innerHTML = `\n      ${t}:\n      x: ${Math.round(i.point.x)};\n      y: ${Math.round(i.point.y)}\n    ` } updateAreaInfo() { document.querySelector(".area").innerHTML = `\n      area: ${Math.round(Math.abs(this.prlg.area))}\n    ` } drawCenterPoint(t, i) { this.centerPoint = new Path.Circle(new Point(t, i), 3), this.centerPoint.fillColor = "black" } redrawCenterPoint() { this.centerPoint.position = new Point(this.x0, this.y0) } resetCanvas() { project.clear(), this.it = 0, this.points = [], this.info.innerHTML = "", this.x0 = this.y0 = null } drawParallelogram() { const { points: t } = this; t.push(this.calculateFourthVertex()), this.prlg = new Path({ segments: this.points.map(t => [t.x, t.y]), strokeColor: "blue", closed: !0 }); const i = this.prlg.area; return this.info.innerHTML += `\n      <p class="area">\n        area: ${Math.round(Math.abs(i))}\n      </p>\n    `, i } redrawParallelogram(t, i) { this[t].position = i.point, this.prlg.curves[i.target.index].point1 = i.point, this.points[i.target.index] = { x: i.point.x, y: i.point.y }, this.prlg.curves[3].point1 = new Point(this.calculateFourthVertex()) } calculateFourthVertex() { const { points: t } = this; return this.x0 = Math.round((t[0].x + t[2].x) / 2), this.y0 = Math.round((t[0].y + t[2].y) / 2), { x: t[0].x + t[2].x - t[1].x, y: t[0].y + t[2].y - t[1].y } } drawCircle(t) { const i = Math.round(Math.sqrt(t / Math.PI)); this.circle = new Path.Circle(new Point(this.x0, this.y0), i), this.circle.strokeColor = "#ead147" } redrawCircle() { const t = Math.round(Math.sqrt(Math.abs(this.prlg.area) / Math.PI)); this.circle.remove(), this.circle = new Path.Circle(new Point(this.x0, this.y0), t), this.circle.strokeColor = "#ead147" } } window.onload = function () { new DrawFigures };
